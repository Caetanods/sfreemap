---
title: "Sfreemap"
author: "Diego Pasqualin, Marcos Barbeitos and Fabiano Silva"
date: "`r Sys.Date()`"
output:
    html_document:
        toc: true
        theme: spacelab
        highligh: textmate
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{apex: Phylogenetic Methods for Multiple Gene Data.}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE}
# set global chunk options: images will be 7x5 inches
knitr::opts_chunk$set(fig.width=7, fig.height=10, fig.path="figs/")
options(digits = 4)
require(ape)
require(sfreemapc)

# load datasets
data(sfreemap.corals.trees)
data(sfreemap.corals.tips)
data(sfreemap.primates.dna.tips)
data(sfreemap.primates.trees)
data(sfreemap.primates.summary.tree)
```

# Introduction

Put some description here so people don't lose their minds...

# Installing *sfreemap*

To install the development version from github:
```{r, eval=FALSE}
library(devtools)
install_github("dpasqualin/sfreemapc")
```

The stable version can be installed from CRAN using:
```{r, eval=FALSE}
install.packages(sfreemapc)
```

Then, to load the package, use:
```{r, eval=FALSE}
library("sfreemapc")
```

# New object classes

One new class of object extend existing data structure for phylogenetic trees:
* **sfreemap:** complements "phylo" and "multiPhylo" classes from ape and phytools with *mapped.edge.lmt*, a matrix containing the expected value for the number of transitions among states.


# Simple stochastic mapping

## Standard type

The program accepts the parameter *type=standard* which should be used when the
character is of morphological type. The dataset *sfreemap.corals.trees* and its
corresponding tip values *sfreemap.corals.tips* can be used as example here.

Just to have an idea of the dataset we are working on, let's have a look at the first tree:

```{r}
plot.phylo(sfreemap.corals.trees[[1]], cex=0.7)
```

The command *sfreemap.map* runs by default with *method='empirical'* and *type='standard'*, so
we don't have supply it now. Please check the package documentation for more details.

*This function will run in parallel with a number of processes equal to the number of cores
in your machine. If you want to disable parallel processing you can pass parallel=FALSE as a third parameter.
Many other function of sfreemap presents this parameter.*

```{r}
data <- sfreemap.map(sfreemap.corals.trees, sfreemap.corals.tips)
class(data)
data
```

All trees have the objects *mapped.edge* and *mapped.edge.lmt*, representing the expected
dwelling times and expected number of transitions for each state on each
branch of the tree. The following commands shows how to use these objects.

```{r}
t <- data[[1]] # Let's work with the first tree
t

# Get the list of the first 10 edges
t$edge[1:10,]

# Get the dwelling times for the first edge, the one connecting node 82 with 83
t$mapped.edge[1,]
# Do the same thing using the branch name
t$mapped.edge['82,83',]

# Do the same thing for number of transitions
t$mapped.edge.lmt['82,83',]
```

## DNA type

Use *type=dna* when working with nucleotides. The datasets *sfreemap.primates.trees* and
*sfreemap.primates.dna.tips* can be used as example.

Again, we will run the program with only the first ten trees. The tips dataset
has several characters, and again we are going to use just the first ten. What the
program will do in this case is to run each tree against each character, in the order
they appear in their respective objects. The result will be ten mapped trees.
Same logic would apply for standard type.

```{r}
sfreemap.map(sfreemap.primates.trees[1:10], sfreemap.primates.dna.tips[,1:10], paralel=FALSE)
```

It is also possible to run the program passing a single tree as parameter and multiple characters.
In this case each have ten trees as result, each one with a mapping that corresponds to
a character.

```{r}
sfreemap.map(sfreemap.primates.trees[[1]], sfreemap.primates.dna.tips[,1:10], parallel=FALSE)
```
Of course, the user can also map a single character into multiple trees, like following:

```{r}
res <- sfreemap.map(sfreemap.primates.trees[1:10], sfreemap.primates.dna.tips[,1], parallel=FALSE)
```

When using a single tree one can compute the mean value across trees for
the number of transitions and dwelling times as follow:

```{r}
# Using result from the last execution
mean.dt <- Reduce('+', lapply(res, function(x) x$mapped.edge)) / length(res)
mean.dt[1:10,] # just the first ten rows to give an idea..
```

Although the command above is quite typical for an R experienced programmer, it
might not be as simple to remember and understand for a more regular user. Besides, what if
we want the median instead of the mean? The command would be completely different.
That is why we provide some tools to analyse the mappings produced by *sfreemap.map* command, which will be described in the next section.

# Analysing mapped data with histograms

As we have shown, the object created by *sfreemap.map* can be analysed and
manipulated to produce summaries and plots. In this section we will show some
tools to make this task a lot easier.

For the examples we will be using the object named *data*, which was calculated in
the first example of the previous section and corresponds to
`r length(data)` mapped trees.

First we will run the function below, which analysis mapping results on all trees, creating
an object with the dwelling times and the number of transitions for every node
of every tree. It tries to match nodes using function *matchNodes* from *phytools*
packages, which consider two nodes to be the same when they share the same taxa.

```{r}
mpd <- sfreemap.map_posterior_distribution(data[[1]], data, scale=TRUE)
```

The first parameter of the function is the so called "base tree", the tree on which the
existence of branches will be compared to. Second parameter is all other trees to be
analysed and the last one is whether we want to scale the dwelling times to the
branch length, resulting in a proportion of the time spent instead of an absolute
value (the expected number of transitions cannot be scaled).


## Expected dwelling times for states of a branch across all trees

Let's suppose we want to check the posterior distribution of states on a specific branch of
the tree. Branches don't usually have names, so we will define a branch by it's ending node.
For example, the code below will plot our base tree and it's correspondent node numbers.

```{r}
plot.phylo(data[[1]], cex=0.7)
nodelabels(cex = .75, bg = "yellow")
```

Picking one node, let's say *89*, we can see the posterior distribution for dwelling times on
the branch that **ends** on node *89* by typing the following command (these are
the default values for arguments *conf_level*, *number_of_ticks* and *type*,
so you can omit it and get the same results):

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, 89, conf_level=95, number_of_ticks=20, type='emr')
```

The interpretation is as follows: the *colonial* state was present with 95% certainty
around 10% and 45% of the time on the branch ending on node 89 and, with equal
certainty, the state *solitary* was present during 55% to 90% of the time on this branch.
At the top of the chart, the text *branch posterior probability: 100%* means that this
particular branch was present on 100% of the trees given as argument to the function
*sfreemap.map_posterior_distribution* and compared to out *base tree*.

It is also possible to plot only one of the states by supplying the *states* argument.

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, 89, states='colonial')
```

## Expected dwelling times for states for all branches across all trees

Quite easy to do that, just omit the *node* parameter and the function will consider
the distribution over all nodes.

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, type='emr')
```

If you want to plot the distribution over a specific set of nodes just pass it
as a vector, like this:

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, nodes=c(89,90), type='emr')
```

## Expected dwelling times for states for all branches on a group of trees

To filter or limit the distribution over a specific group of trees, or maybe
a single tree, pass on the argument *trees*, which work in the same way as
*nodes* and *states*.

```{r, fig.width=6, fig.height=4}
# get the odd trees
trees <- seq(1, length(sfreemap.corals.trees), 2)
sfreemap.plot_distribution(mpd, nodes=89, trees=trees)
```

## Expected number of transitions for states of one or more branches across all trees

Similar plots can be generated for the number of transitions using the same function
and *mpd* object created before, just changing the parameter *type* from *emr* to *lmt*
(labelled markov transitions).

As stated before, it doesn't make sense to scale the number of transitions according to the branch length, so here
the absolute values are represented in the x-axis.

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, 89, type='lmt')
```

Needless to say, but you can plot a single state here in the same way as before:

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, 89, states='solitary', type='lmt')
```
Example considering all nodes and all states:

```{r, fig.width=6, fig.height=4}
sfreemap.plot_distribution(mpd, type='lmt')
```
